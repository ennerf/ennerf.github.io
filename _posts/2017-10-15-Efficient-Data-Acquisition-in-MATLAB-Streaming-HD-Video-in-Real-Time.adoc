= Efficient Data Acquisition in MATLAB: Streaming HD Video in Real-Time
:published_at: 2017-10-15
//:hp-tags: 
//:imagesdir: ../images
//:imagesdir: https://rawgit.com/ennerf/ennerf.github.io/tree/master/images
:imagesdir: https://cdn.rawgit.com/ennerf/ennerf.github.io/8f6a41c7/images
:source-highlighter: none

++++
<link rel="stylesheet" href="https://cdn.rawgit.com/ennerf/ennerf.github.io/master/resources/highlight.js/9.9.0/styles/matlab.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/matlab.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
++++

The acquisition and processing of a video stream can be very computationally expensive. Typical image processing applications split the work across multiple threads, one acquiring the images, and another one running the actual algorithms. In MATLAB we can get multi-threading by interfacing with other languages, but there is a significant cost associated to exchanging data across the resulting language barrier. In this blog post we compare different approaches for getting data through MATLAB's Java interface, and we show how to acquire high resolution video streams in real-time and with low overhead.

//Video acquisition is computationally intensive enough that is has to be done on a background thread. In MATLAB we can easily do this by using interfaces to other languages. However, once the data becomes significantly large, translating the acquired data back into a MATLAB format can quickly become a bottleneck. Below we show a generally applicable approach that we developed for getting 1080p h264 streaming video into MATLAB with very low overhead.

//To work around limitations due to MATLAB's single threaded nature, we often have to resort to use interfaces to other languages, such as MEX or the Java interface, in order to do data acquisition on a background thread. However, in some cases, such as when trying to stream 1080p h264 video, there is so much data that the translation layer to other languages becomes a bottleneck. Below we show how techniques originally developed for inter-process communication can be used to get large amounts of data into MATLAB with very low overhead.

== Motivation

For our booth at ICRA 2014 we put together a demo system in MATLAB that used stereo vision for tracking colored bean bags, and a robot arm to pick them up. We used two IP cameras that streamed link:https://de.wikipedia.org/wiki/H.264[H.264] video over link:https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol[RTSP]. While developing the image processing and robot control parts worked as expected, it proved to be a challenge to acquire images from both video streams fast enough to be useful.

* link:http://www.mathworks.com/hardware-support/ip-camera.html[IP Camera Support] only supports link:https://en.wikipedia.org/wiki/Motion_JPEG[MJPEG] over link:https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol[HTTP] and didn't exist at the time
* link:http://www.mathworks.com/hardware-support/matlab-webcam.html[USB Webcam Support] only supports USB cameras
* link:http://www.mathworks.com/help/matlab/ref/imread.html[imread] and link:http://www.mathworks.com/help/matlab/ref/webread.html[webread] are limited to HTTP and too slow for real-time

Since we did not want to switch to another language, we decided to develop a small library for acquiring video streams. The project was later open sourced as link:http://www.github.com/HebiRobotics/HebiCam[HebiCam].

== Technical Background

In order to save bandwidth most IP cameras compress video before sending it over the network. Since the resulting decoding step can be computationally expensive, it is common practice to move the acquisition to a separate thread in order to reduce the load on the main processing thread.

Doing this in MATLAB unfortunately requires some workarounds due to the language's single threaded nature, i.e., background threads need to run in another language. Out of the box there are two supported interfaces: https://www.mathworks.com/help/matlab/matlab_external/introducing-mex-files.html[MEX] for calling C/C++ code, and the https://www.mathworks.com/help/matlab/matlab_external/product-overview.html[Java Interface] for calling Java code.

While both interfaces have strengths and weaknesses, either one can be used for solving practically any use case. Since this project had to work on all major operating systens, we chose to use the Java interface for its built-in cross-platform support and simplified deployment. The diagram below shows an overview of the resulting system.

////
Since our projects almost always have to work on all major platforms, we tend to favor the Java interface for its simplified deployment and  built-in cross-platform support. However, one of the weaknesses is that the overhead of calling Java methods from MATLAB is higher than the overhead of calling MEX functions. This difference is usually negligible, but it unfortunately becomes noticeable when translating large amounts of data such as high resolution images. 


although the internal performance differences between Java and C++ rarely matter, the overhead of calling Java methods from MATLAB is higher than the overhead of calling MEX functions. This difference is usually negligible, but it unfortunately becomes noticeable when translating large amounts of data such as high resolution images.
////

[.text-center]
.System overview for a stereo vision setup
image::{imagesdir}/streaming/stereocam-matlab.svg[width=100%]

Starting background threads and getting the video stream into Java was relatively straight forward. We used the link:https://github.com/bytedeco/javacv[JavaCV] library, which is a Java wrapper around link:https://opencv.org/[OpenCV] and link:https://www.ffmpeg.org/[FFMpeg] that includes pre-compiled native binaries for all major operating systems. However, passing the acquired image data from Java into MATLAB turned out to be more challenging.

The Java interface automatically converts between Java and MATLAB types by following a set of link:https://www.mathworks.com/help/matlab/matlab_external/handling-data-returned-from-java-methods.html[rules]. This makes it much simpler to develop for than the MEX interface, but it does cause additional overhead when calling Java functions. Most of the time this overhead is negligible. However, for certain types of data, such as large and multi-dimensional matrices, the default rules are very inefficient and can become prohibitively expensive. For example, a `1080x1920x3` MATLAB image matrix gets translated to a `byte[1080][1920][3]` Java array, which means that every single pixel in the image gets stored as a separate array.

As an additional complication, Java images use a different memory layout than MATLAB image matrices. While Java stores pixels in row-major order, MATLAB stores them transposed and in column-major order. For example, if the pixels for a Java image would be laid out as `[RGB][RGB][RGB]...`, the same image would be laid out as `[RRR...][GGG...][BBB...]` in MATLAB.  (`R`, `G`, `B` correspond to red, green, and blue values for one pixel)

In order to process images at a frame rate of 30 fps in real-time, the total time budget of the main MATLAB thread is 33ms per cycle. Thus, the aquisition overhead imposed on the main thread needs to be sufficiently low, i.e., a low number of milliseconds, to leave enough time for the actual processing.


////
* Acquiring video on a background thread
* Transferring data across the language barrier
* Converting to a MATLAB readable format
* Using the image in MATLAB

Getting images in has to happen within max a few ms, otherwise it's impossible to do any actual work on the images. Since decoding can take an entire thread by itself, background threading is required. However, there is too much data to transfer through the standard language barriers.
////

== Data Translation

We benchmarked five different ways to get image data from Java into MATLAB and compared their respective overhead on the main MATLAB thread. We omitted overhead incurred by background threads because it had no effect on the time budget available for image processing.

The full benchmark code is available link:https://github.com/HebiRobotics/HebiCam/tree/benchmark[here].

*1. Default 3D Array*

By default MATLAB image matrices convert to `byte[height][width][channels]` Java arrays. However, when converting back to MATLAB there are some additional problems:

* `byte` gets converted to `int8` instead of `uint8`, resulting in an invalid image matrix
* changing the type back to `uint8` is somewhat messy because the `uint8(matrix)` cast sets all negative values to zero, and the alternative `typecast(matrix, 'uint8')` only works on vectors

Thus, converting the data to a valid image matrix still requires several operations.

[source,matlab]
----
% (1) Get matrix from byte[height][width][channels]
data = getRawFormat3d(this.javaConverter);
[height,width,channels] = size(data);

% (2) Reshape matrix to vector
vector = reshape(data, width * height * channels, 1);

% (3) Cast int8 data to uint8
vector = typecast(vector, 'uint8');

% (4) Reshape vector back to original shape
image = reshape(vector, height, width, channels);
----

*2. Compressed 1D Array*

A common approach to move image data across distributed components (e.g. link:http://www.ros.org/[ROS]) is to encode the individual images using link:https://en.wikipedia.org/wiki/Motion_JPEG[MJPEG] compression. Doing this within a single process is obviously wasteful, but we included it because it is common practice in many distributed systems. Since MATLAB did not offer a way to decompress jpeg images in memory, we needed to save the compressed data to a file located on a RAM disk.

[source,matlab]
----
% (1) Get compressed data from byte[]
data = getJpegData(this.javaConverter);

% (2) Save as jpeg file
fileID = fopen('tmp.jpg','w+');
fwrite(fileID, data, 'int8');
fclose(fileID);

% (3) Read jpeg file
image = imread('tmp.jpg');
----

*3. Java Layout as 1D Pixel Array*

Another approach is to copy the pixel array of Java's `BufferedImage` and to reshape the memory using MATLAB. This is also the acepted answer for link:https://mathworks.com/matlabcentral/answers/100155-how-can-i-convert-a-java-image-object-into-a-matlab-image-matrix#answer_109503[How can I convert a Java Image object to a MATLAB image matrix?].

[source,matlab]
----
% (1) Get data from byte[] and cast to correct type
data = getJavaPixelFormat1d(this.javaConverter);
data = typecast(data, 'uint8');
[h,w,c] = size(this.matlabImage); % get dim info

% (2) Reshape matrix for indexing
pixelsData = reshape(data, 3, w, h);

% (3) Transpose and convert from row major to col major format (RGB case)
image = cat(3, ...
    transpose(reshape(pixelsData(3, :, :), w, h)), ...
    transpose(reshape(pixelsData(2, :, :), w, h)), ...
    transpose(reshape(pixelsData(1, :, :), w, h)));
----

*4. MATLAB Layout as 1D Pixel Array*

The fourth approach also copies a pixel array, but this time the pixels are already stored as in the MATLAB convention.

[source,matlab]
----
% (1) Get data from byte[] and cast to correct type
data = getMatlabPixelFormat1d(this.javaConverter);
[h,w,c] = size(this.matlabImage);  % get dim info
vector = typecast(data, 'uint8');

% (2) Interpret pre-laid out memory as matrix
image = reshape(vector,h,w,c);
----

Note that the most efficient way we found for converting the memory layout on the Java side was to use OpenCV's `split` and `transpose` functions. The code can be found in link:https://github.com/HebiRobotics/HebiCam/blob/master/src/main/java/us/hebi/matlab/streaming/MatlabImageConverterBGR.java[MatlabImageConverterBGR] and link:https://github.com/HebiRobotics/HebiCam/blob/master/src/main/java/us/hebi/matlab/streaming/MatlabImageConverterGrayscale.java[MatlabImageConverterGrayscale].

*5. MATLAB Layout as Shared Memory*

The fifth approach is the same as the fourth with the difference that the Java translation layer is bypassed entirely by using shared memory via link:https://mathworks.com/help/matlab/ref/memmapfile.html[memmapfile]. Shared memory is typically used for inter-process communication, but it can also be used within a single process. Running within the same process also simplifies synchronization since MATLAB can access Java locks.

[source,matlab]
----
% (1) Lock memory
lock(this.javaObj);

% (2) Force a copy of the data
image = this.memFile.Data.pixels * 1;

% (3) Unlock memory
unlock(this.javaObj);
----

Note that the code could be interrupted (ctrl+c) at any line, so the locking mechanism would need to be able to recover from bad states, or the unlocking would need to be guaranteed by using a destructor or link:https://mathworks.com/help/matlab/ref/oncleanup.html[onCleanup].

The multiplication by one forces a copy of the data. This is necessary because under-the-hood `memmapfile` only returns a reference to the underlying memory.

////
We can solve this by doing one of the following

* Make the internal logic smart enough to handle cases where users didn't call `unlock`
* Use link:https://mathworks.com/help/matlab/ref/oncleanup.html[onCleanup] to guarantee unlocking, e.g., `c = onCleanup(@()unlock(this.javaObj))`
* Create a custom class that locks in the constructor and unlocks in the destructor

However, even if the `unlock` call is in a destructor (guaranteed to run when exiting scope), the Java logic still needs to handle cases where the code gets interrupted before the `lock` call.
////

== Results

All benchmarks were run in MATLAB 2017b on an link:https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc6i7kyk.html[Intel NUC6I7KYK]. The performance was measured using MATLAB's link:https://mathworks.com/help/matlab/ref/timeit.html[timeit] function. The background color of each cell in the result tables represents a rough classification of the overhead on the main MATLAB thread.

{set:cellbgcolor:white}

[.text-center]
.Color classification
[width="50%",options="header",cols="^a,^a,^a"]
|====================
| Color |  Overhead | 30 Frames / Sec |
Green |  <10% | <3.3 ms | 
Yellow | <50% | <16.5 ms |
Orange | <100% | <33.3 ms | 
Red |  >100% | >33.3 ms  |
|====================

{set:cellbgcolor!}

The two tables below show the results for converting color (RGB) images as well as grayscale images. All measurements are in milliseconds.

////
* Green: below 10% or 3.3ms at 30 fps
* Yellow: below 50% or 16.5ms at 30 fps
* Orange: below 100% or 33.3ms at 30 fps
* Red: above 100%
////

[.text-center]
.Conversion overhead on the MATLAB thread in [ms]
image::{imagesdir}/streaming/table_performance.svg[width=100%]

The results show that the default conversion as well as jpeg compression are essentially non-starters for color images. For grayscale images the default conversion works significantly better due to the fact that the data is stored in a much more efficient 2D array (`byte[height][width]`), and that there is no need to re-order pixels by color.

[NOTE]
Unfortunately, we currently don't have a good explanation for the ~10x cost increase (rather than ~4x) between 1080p and 4K grayscale. The behavior was the same across computers and different memory settings.

When copying the pixels of a Java image we can see another significant performance increase due to the data being stored in a single contiguous array. At this point much of the overhead comes from re-ordering pixels, so by doing the conversion beforehand we can get another 2-3x improvement.

Lastly, although accessing shared memory in combination with the locking overhead results in a slightly higher fixed cost, the copying itself is significantly cheaper, resulting in another 2-3x speedup for high resolution images. Overall, going through shared memory scales very well and would even allow streaming of 4K color images from two cameras simultaneously.

== Final Notes

As for our initial motiation, after creating link:https://github.com/HebiRobotics/HebiCam[HebiCam] we were able to develop and reliably run the whole demo entirely in MATLAB.

video::R0nQSxt8uic?rel=0[youtube]

Our main takeaway was that although MATLAB's Java interface can be inefficient for certain cases, there are simple workarounds that can remove most bottlenecks. The most important rule is to avoid converting to and from large multi-dimensional matrices whenever possible.

Another insight was that shared memory provides a very efficient way to transfer large amounts of data to and from MATLAB. We also found it useful for inter-process communication between multiple MATLAB instances, e.g., one instance can track a target while another instance can use its output for real-time control. This can be useful to avoid coupling a fast control loop to the (lower) frame rate of a camera or sensor.

////
The biggest takeaway for us was that MATLAB supports shared memory. We had used shared memory before for inter-process communication in Java and C++, but we somehow assumed that MATLAB wouldn't support it. We eventually looked into this and found that MATLAB does have support, and that the implementation is actually quite nice. The data definition can even map the memory to an array of structs with multiple variables.

Using shared memory allows us to transfer data very efficiently and to include meta data such as timestamps or frame sequence numbers. However, for us the most interesting application is still its use for inter process communication. For example, we can have two MATLAB instances exchange almost arbitrary aounts of data by simply defining a common shared struct.

For example, this enables us to run one MATLAB instance that tracks a target at a low rate (e.g. 30 Hz), and another instance for calculating and executing trajectories at a higher rate (e.g. >100 Hz), without needing to setup an inter-process communication framework like link:https://lcm-proj.github.io/[LCM], or the need to define any marshalling or custom binary formats.

We will publish more details about inter-process communication as well as synchronization between multiple MATLAB instances in a future blog post.
////

// Using Java's `Unsafe` we can even implement synchronization mechanisms in shared memory that enable safe inter process communication. This means that we can exchange large amounts of data between MATLAB instances extremely efficiently, without the need for any complex frameworks. The data format can be changed at runtime, without worrying about recompiling and generating message definitions.

////

Unfortunately, while the automated translation from and to Java types tends to be sufficient, it is very inefficient for large and multi dimensional matrices. For example, a 1080x1920x3 MATLAB matrix gets translated to a byte[1080][1920][3] Java array. Thus, there is a separate array object for every single pixel in the image.

We care mostly about reducing the translation part that has to happen on the main MATLAB thread, so in general it is better to do as much of the work before crossing the barrier.

* Default conversion (byte[][][]) allocates a 3 element byte array for every pixel. RGB conversion is a non starter. Greyscale translates to byte[][], which works somewhat better.

* Message passing systems (e.g. ROS) often compress images as e.g. Jpeg before sending it to other nodes. We could do something similar here, but MATLAB doesn't have methods for decompressing memory. Going through a file is pretty expensive. Cheaper for RGB, but more expensive for grayscale.

* Accessing the backing byte[] array of a BufferedImage and then reshaping works better, but needs quite a bit of memory shuffling.

* Matching the memory layout before transporting as a byte[] array is significantly better.

* Using the same data, but transporting via shared memory is even better. There is some minor overhead for locking as well as a single memcopy in MATLAB.
////

////
== Reshaping memory layout

Transposed column Major, i.e., [R R R R ...] [G G G G ...] etc. instead of [RGB][RGB][RGB], and height x width instead of width x height.

* Inside MATLAB using reshape
* Using Java loop
* Using OpenCV calls

== Synchronizing shared memory

* Synchronize using Java locks
** MATLAB doesn't provide locking mechanisms
** Difficult to lock raw memory anyways

* Unlock must be called. no try{}finally{} in MATLAB, but ctrl-c shouldn't end up in bad states
** Work around the issue with extra logic
** use onCleanup()
** use custom handle class with destructor
////

////
Several problems, e.g.,

* Data needs to be locked properly
* Once allocated objects need to continue to work
* User can ctrl+c at any time. There is no guarantee to always call unlock.
** User needs to be able to lock multiple times
** Background thread needs to have a timeout to not break acquisition, e.g., min 1 frame per 5 sec

* try onCleanup(@()f): https://se.mathworks.com/help/matlab/ref/oncleanup.html
** could call unlock() that has bool to know whether it's locked.
////

////
== ------ DEPRECATED ------

In my quest to creating robot APIs for MATLAB I've encountered many problems. One of the most challenging ones was to find a way to acquire h264 video streams in real-time in order to enable quick prototyping of computer vision algorithms.

The acquisition and decoding of a video stream can be a very computationally expensive operation, so in a typical (e.g. C++ or Java) program there would be a background thread acquiring the images and another thread that would run the actual algorithm. This approach doesn't work well for MATLAB since the language is fundamentally single threaded. There are ways to get multi-threading by interfacing with other languages, but there is a significant cost to crossing the barrier to MATLAB and converting the data into a compatible format.

I've tried various different approaches in side projects between 2011 and 2013 to get this running, but I always ended up unsatisfied. Eventually in 2014 this became more of a priority and I finally found a good solution. 

This blog post will provide an overview of the problem, the approaches that didn't work, and the final solution.

== Vanilla MATLAB

MATLAB provides a variety of toolboxes and hardware support packages for image acquisition. Below is a list of the ones that I'm aware of:

[width="100%",options="header",cols="1a,3a"]
|====================
| Package | Problems 

| link:http://www.mathworks.com/hardware-support/ip-camera.html[IP Camera Support] |
* Didn't exist at the time
* Limited to mjpeg over http

| link:http://www.mathworks.com/hardware-support/matlab-webcam.html[USB Webcam Support] |
* Only supports USB cameras

| link:http://www.mathworks.com/help/matlab/ref/imread.html[imread], link:http://www.mathworks.com/help/matlab/ref/webread.html[webread] |
* Does everything in the MATLAB thread, which is too slow (<2 fps) 
* Limited to http

|====================


== Common Approach

// Similar to ROS / LCM - acquire image in 1 process and publish as jpeg
// --> quality reduction and huge load on the system
// --> not feasible for >480p

// MATLAB thread: retrieve encoded data, decode to raw, convert to matlab format

Assuming a frame rate of 30 fps, the total time budget in the MATLAB thread is 33 ms per image. In order to be able to actually do useful operations on the images, the acquisition part shouldn't take more than 5-10 ms.

// ROS toolbox -> ros/msg/sensor_msgs/internal/ImageReader.decompressImg() uses javax.imageIO to read jpeg, then converts to uint8 array and does reshape.

== Dedicated System

// implemented as much as possible in background thread, direct acquisition

// MATLAB thread: convert to MATLAB format

link:http://www.mathworks.com/matlabcentral/fileexchange/8028-mmread[mmread] uses MEX with FFMpeg. 
link:https://github.com/kyamagu/mexopencv[mexopencv] uses MEX with OpenCV.


== Efficient Data Exchange

// MATLAB thread: 2 very cheap Java calls for locking and a memcpy operation
////






