= Interfacing with MATLAB : Streaming HD Video in Real-Time
:published_at: 2016-10-10
//:hp-tags: 
:imagesdir: ../images

The acquisition and decoding of a video stream can be very computationally expensive. Typical image processing applications thus split the work across multiple threads, one acquiring the images, and another one running the actual algorithms. In MATLAB we can get multi-threading by interfacing with other languages, but there is a significant cost associated to exchanging data across the resulting language barrier. For large images the standard ways for converting data can be prohibitively expensive. Below we show a generally applicable workaround that enables streaming 1080p h264 video into MATLAB in real-time and with very low overhead. 

//Video acquisition is computationally intensive enough that is has to be done on a background thread. In MATLAB we can easily do this by using interfaces to other languages. However, once the data becomes significantly large, translating the acquired data back into a MATLAB format can quickly become a bottleneck. Below we show a generally applicable approach that we developed for getting 1080p h264 streaming video into MATLAB with very low overhead.

//To work around limitations due to MATLAB's single threaded nature, we often have to resort to use interfaces to other languages, such as MEX or the Java interface, in order to do data acquisition on a background thread. However, in some cases, such as when trying to stream 1080p h264 video, there is so much data that the translation layer to other languages becomes a bottleneck. Below we show how techniques originally developed for inter-process communication can be used to get large amounts of data into MATLAB with very low overhead.

== The Need / Problem statement

Why didn't built-in solutions work?

Getting images in has to happen within max a few ms, otherwise it's impossible to do any actual work on the images. Since decoding can take an entire thread by itself, background threading is required. However, there is too much data to transfer through the standard language barriers.

== Common approaches / Failures / What didn't work

byte[][][] is a non-starter. Doing standard workarounds like 1D arrays with reshaping works better, but moves too much data processing into the MATLAB thread. Compression doesnt work.

== The Solution

Shared Memory w/ pre-layed out data that can be memcpy'd.

== Solving the synchronization issue

Several problems, e.g.,

* Data needs to be locked properly
* Once allocated objects need to continue to work
* User can ctrl+c at any time. There is no guarantee to always call unlock.
** User needs to be able to lock multiple times
** Background thread needs to have a timeout to not break acquisition, e.g., min 1 frame per 5 sec

* try onCleanup(@()f): https://se.mathworks.com/help/matlab/ref/oncleanup.html
** could call unlock() that has bool to know whether it's locked.

== ------ DEPRECATED ------

In my quest to creating robot APIs for MATLAB I've encountered many problems. One of the most challenging ones was to find a way to acquire h264 video streams in real-time in order to enable quick prototyping of computer vision algorithms.

The acquisition and decoding of a video stream can be a very computationally expensive operation, so in a typical (e.g. C++ or Java) program there would be a background thread acquiring the images and another thread that would run the actual algorithm. This approach doesn't work well for MATLAB since the language is fundamentally single threaded. There are ways to get multi-threading by interfacing with other languages, but there is a significant cost to crossing the barrier to MATLAB and converting the data into a compatible format.

I've tried various different approaches in side projects between 2011 and 2013 to get this running, but I always ended up unsatisfied. Eventually in 2014 this became more of a priority and I finally found a good solution. 

This blog post will provide an overview of the problem, the approaches that didn't work, and the final solution.

== Vanilla MATLAB

MATLAB provides a variety of toolboxes and hardware support packages for image acquisition. Below is a list of the ones that I'm aware of:

[width="100%",options="header",cols="1a,3a"]
|====================
| Package | Problems 

| link:http://www.mathworks.com/hardware-support/ip-camera.html[IP Camera Support] |
* Didn't exist at the time
* Limited to mjpeg over http

| link:http://www.mathworks.com/hardware-support/matlab-webcam.html[USB Webcam Support] |
* Only supports USB cameras

| link:http://www.mathworks.com/help/matlab/ref/imread.html[imread], link:http://www.mathworks.com/help/matlab/ref/webread.html[webread] |
* Does everything in the MATLAB thread, which is too slow (<2 fps) 
* Limited to http

|====================


== Common Approach

// Similar to ROS / LCM - acquire image in 1 process and publish as jpeg
// --> quality reduction and huge load on the system
// --> not feasible for >480p

// MATLAB thread: retrieve encoded data, decode to raw, convert to matlab format

Assuming a frame rate of 30 fps, the total time budget in the MATLAB thread is 33 ms per image. In order to be able to actually do useful operations on the images, the acquisition part shouldn't take more than 5-10 ms.

// ROS toolbox -> ros/msg/sensor_msgs/internal/ImageReader.decompressImg() uses javax.imageIO to read jpeg, then converts to uint8 array and does reshape.

== Dedicated System

// implemented as much as possible in background thread, direct acquisition

// MATLAB thread: convert to MATLAB format

link:http://www.mathworks.com/matlabcentral/fileexchange/8028-mmread[mmread] uses MEX with FFMpeg. 
link:https://github.com/kyamagu/mexopencv[mexopencv] uses MEX with OpenCV.


== Efficient Data Exchange

// MATLAB thread: 2 very cheap Java calls for locking and a memcpy operation







