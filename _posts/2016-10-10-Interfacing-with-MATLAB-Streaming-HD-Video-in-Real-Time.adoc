= Interfacing with MATLAB : Streaming HD Video in Real-Time
:published_at: 2016-10-10
//:hp-tags: 
:imagesdir: ../images

The acquisition and decoding of a video stream can be very computationally expensive. Typical image processing applications split the work across multiple threads, one acquiring the images, and another one running the actual algorithms. In MATLAB we can get multi-threading by interfacing with other languages, but there is a significant cost associated to exchanging data across the resulting language barrier. The default ways for data conversion can quickly become prohibitively expensive. In this blog post we compare different approaches for getting data from MATLAB's Java interface, and we show how to stream 1080p h264 video into MATLAB in real-time and with very low overhead.

//Video acquisition is computationally intensive enough that is has to be done on a background thread. In MATLAB we can easily do this by using interfaces to other languages. However, once the data becomes significantly large, translating the acquired data back into a MATLAB format can quickly become a bottleneck. Below we show a generally applicable approach that we developed for getting 1080p h264 streaming video into MATLAB with very low overhead.

//To work around limitations due to MATLAB's single threaded nature, we often have to resort to use interfaces to other languages, such as MEX or the Java interface, in order to do data acquisition on a background thread. However, in some cases, such as when trying to stream 1080p h264 video, there is so much data that the translation layer to other languages becomes a bottleneck. Below we show how techniques originally developed for inter-process communication can be used to get large amounts of data into MATLAB with very low overhead.

== Motivation

We typically create new robot systems or demo applications for every ICRA or IROS conference we go to. For our ICRA 2014 demo we had two IP cameras in the office and decided to do a demo based on stereo vision, i.e., a robot arm that can pick bean bags. While the robot control and the stereo vision part were fairly simple to do in MATLAB, it proved to be more difficult than we anticipated to get streaming h264 video from two cameras in real time.

The link:http://www.mathworks.com/hardware-support/ip-camera.html[IP Camera Support] package is limited to MJPEG over HTTP (and didn't exist at the time), the link:http://www.mathworks.com/hardware-support/matlab-webcam.html[USB Webcam Support] package only supports USB cameras, and  link:http://www.mathworks.com/help/matlab/ref/imread.html[imread] as well as link:http://www.mathworks.com/help/matlab/ref/webread.html[webread] are limited to HTTP and are too slow for real-time.

Since we didn't want to port code to another language, we instead wrote a small library that can stream video from various sources with low overhead. We open sourced the project as link:http://www.github.com/HebiRobotics/HebiCam[HebiCam].

== Technical Background

Out of the box MATLAB provides two interfaces to other languages:  https://www.mathworks.com/help/matlab/matlab_external/introducing-mex-files.html[MEX] for calling C/C++ code, and the https://www.mathworks.com/help/matlab/matlab_external/product-overview.html[Java Interface] for calling Java code. In our case we chose the Java interface to simplify development and deployment. 

the choice came down to a trade-off between ease of development versus translation cost.


MATLAB comes with two built-in interfaces to other languages, the 

TODO: Image explaining the various steps.

* Acquiring video on a background thread
* Transferring data across the language barrier
* Converting to a MATLAB readable format
* Using the image in MATLAB


For this project we chose to do it using the Java interface. 


Assuming a frame rate of 30 fps, the total time budget in the MATLAB thread is 33 ms per image. In order to be able to actually do useful operations on the images, the acquisition part shouldn't take more than 5-10 ms.


Why didn't built-in solutions work?

Getting images in has to happen within max a few ms, otherwise it's impossible to do any actual work on the images. Since decoding can take an entire thread by itself, background threading is required. However, there is too much data to transfer through the standard language barriers.

== Copy Approaches & Benchmarks

We care mostly about reducing the translation part that has to happen on the main MATLAB thread, so in general it is better to do as much of the work before crossing the barrier.

* Default conversion (byte[][][]) allocates a 3 element byte array for every pixel. RGB conversion is a non starter. Greyscale translates to byte[][], which works somewhat better.

* Message passing systems (e.g. ROS) often compress images as e.g. Jpeg before sending it to other nodes. We could do something similar here, but MATLAB doesn't have methods for decompressing memory. Going through a file is pretty expensive. Cheaper for RGB, but more expensive for grayscale.

* Accessing the backing byte[] array of a BufferedImage and then reshaping works better, but needs quite a bit of memory shuffling.

* Matching the memory layout before transporting as a byte[] array is significantly better.

* Using the same data, but transporting via shared memory is even better. There is some minor overhead for locking as well as a single memcopy in MATLAB.

Create table with benchmark data. Highlight colors depending on ratio of max processing time (i.e. 30 FPS -> 33.3ms processing budget). 

* below 10% (3.3ms)
* below 50% (16.5ms)
* below 100% (33.3ms)
* above 100%

== Reshaping memory layout

Transposed column Major, i.e., [R R R R ...] [G G G G ...] etc. instead of [RGB][RGB][RGB], and height x width instead of width x height.

* Inside MATLAB using reshape
* Using Java loop
* Using OpenCV calls

== Synchronizing shared memory

* Synchronize using Java locks
** MATLAB doesn't provide locking mechanisms
** Difficult to lock raw memory anyways

* Unlock must be called. no try{}finally{} in MATLAB, but ctrl-c shouldn't end up in bad states
** Work around the issue with extra logic
** use onCleanup()
** use custom handle class with destructor

////
Several problems, e.g.,

* Data needs to be locked properly
* Once allocated objects need to continue to work
* User can ctrl+c at any time. There is no guarantee to always call unlock.
** User needs to be able to lock multiple times
** Background thread needs to have a timeout to not break acquisition, e.g., min 1 frame per 5 sec

* try onCleanup(@()f): https://se.mathworks.com/help/matlab/ref/oncleanup.html
** could call unlock() that has bool to know whether it's locked.
////

== Final Notes

It's definitely possible to transfer large amounts of data across the Java barrier. Shared memory works quite well.

== ------ DEPRECATED ------

In my quest to creating robot APIs for MATLAB I've encountered many problems. One of the most challenging ones was to find a way to acquire h264 video streams in real-time in order to enable quick prototyping of computer vision algorithms.

The acquisition and decoding of a video stream can be a very computationally expensive operation, so in a typical (e.g. C++ or Java) program there would be a background thread acquiring the images and another thread that would run the actual algorithm. This approach doesn't work well for MATLAB since the language is fundamentally single threaded. There are ways to get multi-threading by interfacing with other languages, but there is a significant cost to crossing the barrier to MATLAB and converting the data into a compatible format.

I've tried various different approaches in side projects between 2011 and 2013 to get this running, but I always ended up unsatisfied. Eventually in 2014 this became more of a priority and I finally found a good solution. 

This blog post will provide an overview of the problem, the approaches that didn't work, and the final solution.

== Vanilla MATLAB

MATLAB provides a variety of toolboxes and hardware support packages for image acquisition. Below is a list of the ones that I'm aware of:

[width="100%",options="header",cols="1a,3a"]
|====================
| Package | Problems 

| link:http://www.mathworks.com/hardware-support/ip-camera.html[IP Camera Support] |
* Didn't exist at the time
* Limited to mjpeg over http

| link:http://www.mathworks.com/hardware-support/matlab-webcam.html[USB Webcam Support] |
* Only supports USB cameras

| link:http://www.mathworks.com/help/matlab/ref/imread.html[imread], link:http://www.mathworks.com/help/matlab/ref/webread.html[webread] |
* Does everything in the MATLAB thread, which is too slow (<2 fps) 
* Limited to http

|====================


== Common Approach

// Similar to ROS / LCM - acquire image in 1 process and publish as jpeg
// --> quality reduction and huge load on the system
// --> not feasible for >480p

// MATLAB thread: retrieve encoded data, decode to raw, convert to matlab format

Assuming a frame rate of 30 fps, the total time budget in the MATLAB thread is 33 ms per image. In order to be able to actually do useful operations on the images, the acquisition part shouldn't take more than 5-10 ms.

// ROS toolbox -> ros/msg/sensor_msgs/internal/ImageReader.decompressImg() uses javax.imageIO to read jpeg, then converts to uint8 array and does reshape.

== Dedicated System

// implemented as much as possible in background thread, direct acquisition

// MATLAB thread: convert to MATLAB format

link:http://www.mathworks.com/matlabcentral/fileexchange/8028-mmread[mmread] uses MEX with FFMpeg. 
link:https://github.com/kyamagu/mexopencv[mexopencv] uses MEX with OpenCV.


== Efficient Data Exchange

// MATLAB thread: 2 very cheap Java calls for locking and a memcpy operation







