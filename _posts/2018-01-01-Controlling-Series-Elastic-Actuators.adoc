= Controlling Series Elastic Actuators
:published_at: 2018-01-01
:hp-tags: Series Elastic Actuation, PID
:imagesdir: ../images
//:imagesdir: https://github.com/ennerf/ennerf.github.io/raw/master/images/
:source-highlighter: none
:stem: latexmath

////
equation below: 

stem:[x^2 - y^2 = (x + y)(x - y)]

.Inline macro
latexmath:[$C = \alpha + \beta Y^{\gamma} + \epsilon$]
////

Intro

== PID Control

really quick overview of the standard graph, standard equations, and maybe some short pseudo code

* Simplified PID controller for position w/ motion controller input
* Equations for PID
* MATLAB-pseudo code for PID

== Series Elastic Actuators

* Mechanical setup, what are SEAs?
* Benefits of compliance and torque control

* Spring introduces oscillations -> considered difficult to control
** Kp is limited
** I controller has practical issues (windup etc.) and increases instability
** D controller adds damping and is very important. Unfortunately deriving noisy sensors with small dts introduces a lot of noise, so Kd is limited as well.

== Proportional Control / Virtual Spring

A proportional controller an be thought of as a virtual spring with the stiffness _Kp_. Increasing the stiffness results in less steady state error and more accurate position control. Thus, high precision systems tend to run with very stiff gains.

Since a virtual spring can never respond as fast as a physical response, the maximum stiffness is fundamentally limited by the physical stiffness of the system. If the virtual spring is set to be stiffer than the underlying physical system, the response will oscillate and become unstable.

This poses a problem for series elastic actuators as they by definition contain a spring. The stiffness of the SEA's physical spring is a sliding scale between good position control and accurate force control. Typical factors when choosing the physical spring stiffness include: 

* accurate position control (stiffer is better)
* force/torque resolution (softer is better)
* impact protection (softer is better)
* energy storage (softer is better)

One way to further increase the gain _Kp_ is by adding damping.

adding a virtual damper using derivative control.


== Derivative Control / Virtual Damper

The derivative controller is often thought of as a virtual damper as it damps out the response of the proportional controller. It does this by looking at the _derivative of the error signal_. In practice, the derivative controller has two main problems: 

* The derivative always lags because it has to be differentiated numerically
* Numerical differentiation amplifies sensor noise, which limits the usable range for _Kd_

It is sometimes a bit abstract to think about the _derivative of the error signal_, but we can reason about this a bit differently. A derivative controller is mathematically equivalent to a proportional controller on a matching velocity input signal.

latexmath:[Kd * \frac{\Delta error}{\Delta t} = Kd * \frac{\Delta position_{cmd} - \Delta position_{fbk}}{\Delta t}]

latexmath:[ Kp * ( velocity_{cmd} - velocity_{fbk})]

So adding a derivative term really just means that we would also like to track the velocity. However, while they may be theoretically equivalent, a separation into two controllers yields some practical benefits. First, we can reduce the lag and noise introduced by the numerical differentiation:

* The motion generator already knows the desired velocity for any point in time, so we can reduce lag by not having to derive it in the controller.
* It is easier to build better models for improving the velocity feedback when it is separated from commands, e.g., kalman filters and sensor fusion.

Second, there is a known relationship between the desired (no-load) spinning velocity and the required input PWM when voltage controlling an electric motor. It depends on mechanical properties (e.g. gear ratio), the motor speed constant (add definition), as well as the motor state (e.g. winding temperature).

Knowing these properties, we can calculate a feed forward term that results in roughly the right output. This significantly improves velocity tracking while keeping the _Kp_ gain low. With a good model, most of the controller can be calculated open-loop, which makes the controller less subsceptible to noise. Open-loop systems are also always stable and can't introduce oscillations.

== What else can we model? Dynamics

Important especially for fast dynamic motions

=== Gravity

Introduces constant acceleration in one direction. Often overcome with I controller on position. Given a model of the robot, we can calculate torques that can negate gravity. Even a poor model already helps significantly.

=== Accelerations

Joint accelerations due to the motion. Same as velocity. The motion controller already knows what the accelerations should be, so we are able to calculate torques using  dynamics.

=== Force/Torque controller

* Can also make use of feed forward term via motor torque constant. Even if there is no torque sensor.
* sum(velocityFF + torqueFF) with a perfect model would already be what we want

Model is not perfect, so we still need some amount of closed-loop control

* 90% open-loop for effects we can model
* 10% closed-loop to account for errors in the model

== Combining Position/Velocity/Force

We think this the right level of abstraction for an actuator

* Same units as kinematics/dynamics when doing calculations for a system
* Everything needed for ‘good tracking’ of pos/vel/force should be embedded in the actuator.
* Making use of feedforward terms for velocity/torque when voltage-controlling motors.

* Local controllers don't have to introduce lag by deriving velocity/acceleratory effects themselves

++++
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<link rel="stylesheet" href="https://cdn.rawgit.com/ennerf/ennerf.github.io/master/resources/highlight.js/9.9.0/styles/matlab.css">
<!-- TODO: figure out how to keep Hubpress from adding the default code highlighter to make this work -->
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>-->
<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/matlab.min.js"></script>-->
<!--<script type="text/javascript">hljs.initHighlightingOnLoad()</script>-->
++++