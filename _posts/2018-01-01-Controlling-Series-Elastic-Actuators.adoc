= Controlling Series Elastic Actuators
:published_at: 2018-01-01
:hp-tags: Series Elastic Actuation, PID
:imagesdir: ../images
//:imagesdir: https://github.com/ennerf/ennerf.github.io/raw/master/images/
:source-highlighter: none
:stem: latexmath

////
equation below: 

stem:[x^2 - y^2 = (x + y)(x - y)]

.Inline macro
latexmath:[$C = \alpha + \beta Y^{\gamma} + \epsilon$]
////

Intro

== PID Control

really quick overview of the standard graph, standard equations, and maybe some short pseudo code

* Simplified PID controller for position w/ motion controller input
* Equations for P/I/D
* MATLAB-pseudo code for P/I/D

== Series Elastic Actuators

* Mechanical setup, what are SEAs?
* Benefits of compliance and torque control

* Spring introduces oscillations -> considered difficult to control
** Kp is limited
** I-controller has practical issues (windup etc.) and increases instability
** D-Controller adds damping and is very important. Unfortunately deriving noisy sensors with small dts introduces a lot of noise, so Kd is limited as well.

== Derivative Control

The D-controller works on the _derivative of the error signal_. This sounds a bit abstract and can be a bit difficult to imagine. However, we can reason about this differently:

latexmath:[Kd * \frac{d error}{dt} = Kd * (\frac{d}{dt}position_{cmd} - \frac{d}{dt}position_{fbk})]

In theory, a D-controller on position is mathematically the same as a P-controller on velocity.

latexmath:[ Kp * ( velocity_{cmd} - velocity_{fbk})]

However, while they are theoretically equivalent, there are some practical benefits for treating them separately.

* The motion generator already knows the desired velocity for every point in time. Thus, we can get zero lag velocity input as the value doesn't need to be derived numerically.
* Potentially better velocity feedback, e.g., kalman filter w/ sensor fusion instead of simple diff. (fancy models could be integrated into the D-term as well)
* More resilient to timing and jitter. We can loose commands without the derivative going bad (is this true? is there a difference?)

However, most importantly, it provides a nice way to do feed forward control. For BLDC motors there is a motor speed constant (add definition) that describes the required input voltage to reach a desired speed (spinning with no load). Using this, we can create an open-loop model that pushes the output into the right ballpark.

* A better model of the world requires the P-controller to work less hard
* Open loop systems can't introduce oscillations and are inherently stable
* Significantly reduces noise issues coming from deriving position feedback
* Reduces lag

== What else can we model? Dynamics

Important especially for fast dynamic motions

=== Gravity

Introduces constant acceleration in one direction. Often overcome with I controller on position. Given a model of the robot, we can calculate torques that can negate gravity. Even a poor model already helps significantly.

=== Accelerations

Joint accelerations due to the motion. Same as velocity. The motion controller already knows what the accelerations should be, so we are able to calculate torques using  dynamics.

=== Force/Torque controller

* Can also make use of feed forward term via motor torque constant. Even if there is no torque sensor.
* sum(velocityFF + torqueFF) with a perfect model would already be what we want

Model is not perfect, so we still need some amount of closed-loop control

* 90% open-loop for effects we can model
* 10% closed-loop to account for errors in the model

== Combining Position/Velocity/Force

We think this the right level of abstraction for an actuator

* Same units as kinematics/dynamics when doing calculations for a system
* Everything needed for ‘good tracking’ of pos/vel/force should be embedded in the actuator.
* Making use of feedforward terms for velocity/torque when voltage-controlling motors.

* Local controllers don't have to introduce lag by deriving velocity/acceleratory effects themselves

++++
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<link rel="stylesheet" href="https://cdn.rawgit.com/ennerf/ennerf.github.io/master/resources/highlight.js/9.9.0/styles/matlab.css">
<!-- TODO: figure out how to keep Hubpress from adding the default code highlighter to make this work -->
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>-->
<!--<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/matlab.min.js"></script>-->
<!--<script type="text/javascript">hljs.initHighlightingOnLoad()</script>-->
++++